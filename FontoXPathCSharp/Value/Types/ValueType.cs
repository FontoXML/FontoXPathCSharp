namespace FontoXPathCSharp.Value.Types;

public enum ValueType
{
    XsBoolean,
    XsString,
    XsNumeric,
    XsQName,
    Node,
    Function,
    None,
    XsInteger,
    Item,
    XsAnyAtomicType,
    XsUntypedAtomic,
    XsDecimal,
    XsDouble,
    XsFloat,
    Array,
    XsUnsignedShort,
    XsUnsignedByte,
    XsDuration,
    XsDateTime,
    XsTime,
    XsDate,
    XsGYearMonth,
    DocumentNode,
    ProcessingInstruction,
    Text,
    Attribute,
    Comment,
    Element,
    Map,
    XsError,
    XsDayTimeDuration,
    XsYearMonthDuration,
    XsNonNegativeInteger,
    XsPositiveInteger,
    XsUnsignedInt,
    XsUnsignedLong,
    XsShort,
    XsByte,
    XsInt,
    XsLong,
    XsNonPositiveInteger,
    XsNegativeInteger,
    XsEntity,
    XsEntities,
    XsNcName,
    XsIdRef,
    XsIdRefs,
    XsId,
    XsName,
    XsToken,
    XsNmToken,
    XsNmTokens,
    XsLanguage,
    XsNormalizedString,
    XsDateTimeStamp,
    XsNotation,
    XsAnyUri,
    XsBase64Binary,
    XsHexBinary,
    XsGMonth,
    XsGDay,
    XsGMonthDay,
    XsGYear,
    XsAnySimpleType
}

internal static class ValueTypeUtils
{
	public static string ToString(this ValueType input)
	{
		return input switch
		{
			ValueType.XsBoolean             => "xs:boolean",
			ValueType.XsString              => "xs:string",
			ValueType.XsNumeric             => "xs:numeric",
			ValueType.XsDouble              => "xs:double",
			ValueType.XsDecimal             => "xs:decimal",
			ValueType.XsInteger             => "xs:integer",
			ValueType.XsFloat               => "xs:float",
			ValueType.XsDate                => "xs:date",
			ValueType.XsTime                => "xs:time",
			ValueType.XsDateTime            => "xs:dateTime",
			ValueType.XsDateTimeStamp       => "xs:dateTimeStamp",
			ValueType.XsGYearMonth          => "xs:gYearMonth",
			ValueType.XsGYear               => "xs:gYear",
			ValueType.XsGMonthDay           => "xs:gMonthDay",
			ValueType.XsGMonth              => "xs:gMonth",
			ValueType.XsGDay                => "xs:gDay",
			ValueType.XsYearMonthDuration   => "xs:yearMonthDuration",
			ValueType.XsDayTimeDuration     => "xs:dayTimeDuration",
			ValueType.XsDuration            => "xs:duration",
			ValueType.XsUntypedAtomic       => "xs:untypedAtomic",
			ValueType.XsAnyUri              => "xs:anyURI",
			ValueType.XsBase64Binary        => "xs:base64Binary",
			ValueType.XsHexBinary           => "xs:hexBinary",
			ValueType.XsQName               => "xs:QName",
			ValueType.XsNcName              => "xs:NCName",
			ValueType.XsName                => "xs:Name",
			ValueType.XsEntity              => "xs:ENTITY",
			ValueType.XsNonPositiveInteger  => "xs:nonPositiveInteger",
			ValueType.XsNegativeInteger     => "xs:negativeInteger",
			ValueType.XsPositiveInteger     => "xs:positiveInteger",
			ValueType.XsNonNegativeInteger  => "xs:nonNegativeInteger",
			ValueType.XsLong                => "xs:long",
			ValueType.XsInt                 => "xs:int",
			ValueType.XsShort               => "xs:short",
			ValueType.XsByte                => "xs:byte",
			ValueType.XsUnsignedInt         => "xs:unsignedInt",
			ValueType.XsUnsignedLong        => "xs:unsignedLong",
			ValueType.XsUnsignedByte        => "xs:unsignedByte",
			ValueType.XsUnsignedShort       => "xs:unsignedShort",
			ValueType.XsError               => "xs:error",
			ValueType.XsEntities            => "xs:ENTITIES",
			ValueType.XsIdRef               => "xs:IDREF",
			ValueType.XsId                  => "xs:ID",
			ValueType.XsIdRefs              => "xs:IDREFS",
			ValueType.XsNotation            => "xs:NOTATION",
			ValueType.XsAnySimpleType       => "xs:anySimpleType",
			ValueType.XsAnyAtomicType       => "xs:anyAtomicType",
			ValueType.Attribute             => "attribute()",
			ValueType.XsNormalizedString    => "xs:normalizedString",
			ValueType.XsNmTokens            => "xs:NMTOKENS",
			ValueType.XsNmToken             => "xs:NMTOKEN",
			ValueType.XsLanguage            => "xs:language",
			ValueType.XsToken               => "xs:token",
			ValueType.Node                  => "node()",
			ValueType.Element               => "element()",
			ValueType.DocumentNode          => "document-node()",
			ValueType.Text                  => "text()",
			ValueType.ProcessingInstruction => "processing-instruction()",
			ValueType.Comment               => "comment()",
			ValueType.Item                  => "item()",
			ValueType.Function              => "function(*)",
			ValueType.Map                   => "map(*)",
			ValueType.Array                 => "array(*)",
			ValueType.None                  => "none",
			_ => throw new InvalidOperationException($"Unkown value type {input}")
		};
	}

	public static ValueType StringToValueType(this string input)
	{
		if (input == "none")
		{
			throw new Exception("XPST0051: The type \"none\" could not be found");
		}

		if (!input.StartsWith("xs:", StringComparison.Ordinal) && input.IndexOf(':', StringComparison.Ordinal) >= 0)
		{
			throw new Exception("XPST0081: Invalid prefix for input \"{input}\"");
		}

		return input switch
		{
			"xs:boolean" => ValueType.XsBoolean,
			"xs:string" => ValueType.XsString,
			"xs:numeric" => ValueType.XsNumeric,
			"xs:double" => ValueType.XsDouble,
			"xs:decimal" => ValueType.XsDecimal,
			"xs:integer" => ValueType.XsInteger,
			"xs:float" => ValueType.XsFloat,
			"xs:date" => ValueType.XsDate,
			"xs:time" => ValueType.XsTime,
			"xs:dateTime" => ValueType.XsDateTime,
			"xs:dateTimeStamp" => ValueType.XsDateTimeStamp,
			"xs:gYearMonth" => ValueType.XsGYearMonth,
			"xs:gYear" => ValueType.XsGYear,
			"xs:gMonthDay" => ValueType.XsGMonthDay,
			"xs:gMonth" => ValueType.XsGMonth,
			"xs:gDay" => ValueType.XsGDay,
			"xs:yearMonthDuration" => ValueType.XsYearMonthDuration,
			"xs:dayTimeDuration" => ValueType.XsDayTimeDuration,
			"xs:duration" => ValueType.XsDuration,
			"xs:untypedAtomic" => ValueType.XsUntypedAtomic,
			"xs:anyURI" => ValueType.XsAnyUri,
			"xs:base64Binary" => ValueType.XsBase64Binary,
			"xs:hexBinary" => ValueType.XsHexBinary,
			"xs:QName" => ValueType.XsQName,
			"xs:NCName" => ValueType.XsNcName,
			"xs:Name" => ValueType.XsName,
			"xs:ENTITY" => ValueType.XsEntity,
			"xs:nonPositiveInteger" => ValueType.XsNonPositiveInteger,
			"xs:negativeInteger" => ValueType.XsNegativeInteger,
			"xs:positiveInteger" => ValueType.XsPositiveInteger,
			"xs:nonNegativeInteger" => ValueType.XsNonNegativeInteger,
			"xs:long" => ValueType.XsLong,
			"xs:int" => ValueType.XsInt,
			"xs:short" => ValueType.XsShort,
			"xs:byte" => ValueType.XsByte,
			"xs:unsignedInt" => ValueType.XsUnsignedInt,
			"xs:unsignedLong" => ValueType.XsUnsignedLong,
			"xs:unsignedByte" => ValueType.XsUnsignedByte,
			"xs:unsignedShort" => ValueType.XsUnsignedShort,
			"xs:error" => ValueType.XsError,
			"xs:ENTITIES" => ValueType.XsEntities,
			"xs:IDREF" => ValueType.XsIdRef,
			"xs:ID" => ValueType.XsId,
			"xs:IDREFS" => ValueType.XsIdRefs,
			"xs:NOTATION" => ValueType.XsNotation,
			"xs:anySimpleType" => ValueType.XsAnySimpleType,
			"xs:anyAtomicType" => ValueType.XsAnyAtomicType,
			"attribute()" => ValueType.Attribute,
			"xs:normalizedString" => ValueType.XsNormalizedString,
			"xs:NMTOKENS" => ValueType.XsNmTokens,
			"xs:NMTOKEN" => ValueType.XsToken,
			"xs:language" => ValueType.XsLanguage,
			"xs:token" => ValueType.XsToken,
			"node()" => ValueType.Node,
			"element()" => ValueType.Element,
			"document-node()" => ValueType.DocumentNode,
			"text()" => ValueType.Text,
			"processing-instruction()" => ValueType.ProcessingInstruction,
			"comment()" => ValueType.Comment,
			"item()" => ValueType.Item,
			"function(*)" => ValueType.Function,
			"map(*)" => ValueType.Map,
			"array(*)" => ValueType.Array,
			_ => throw new Exception($"XPST0051: The type \"{input}\" could not be found")
		};
	}
}